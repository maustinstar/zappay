//
//  MessagesViewController.swift
//  zapmessage
//
//  Created by Michael Verges on 10/26/19.
//  Copyright Â© 2019 Michael Verges. All rights reserved.
//

import UIKit
import Messages

class MessagesViewController: MSMessagesAppViewController {
    
    @IBOutlet weak var keypad: UIStackView!
    @IBOutlet weak var acceptView: UIStackView!
    @IBOutlet weak var requestView: UIStackView!
    var participants: [UUID]? = [] {
        didSet {
            multiplier = participants?.count ?? 0
        }
    }
    
    @IBOutlet weak var multiplierLabel: UILabel!
    var multiplier = 0 {
        didSet {
            multiplierLabel.text = "\(multiplier)"
        }
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        checkState()
        
        // Do any additional setup after loading the view.
    }
    
    @IBOutlet weak var acceptValueLabel: UILabel!
    @IBOutlet weak var payeeLabel: UILabel!
    func checkState() {
        
        acceptView.isHidden = true
        keypad.isHidden = true
        guard let messageURL = activeConversation?.selectedMessage?.url else { return }
        guard let urlComponents = NSURLComponents(url: messageURL, resolvingAgainstBaseURL: false) else { return }
        guard let queryItems = urlComponents.queryItems else { return }
        if queryItems.isEmpty { return }
        var items: [String: String] = [:]
        queryItems.forEach { (item) in items[item.name] = item.value ?? "" }
        
        requestView.isHidden = true
        self.acceptView.isHidden = false
        
        
        guard let count = Int(items["count"] ?? "") else { return }
        var isComplete = false
        for i in 0..<count {
            ZWServer.checkTransfer(id: items["transfer_id\(i)"] ?? "") { (id, balance) in
                if !isComplete {
                    self.idForConfirmation = "transfer_id\(i)"
                    isComplete = true
                    DispatchQueue.main.sync {
                        self.acceptValueLabel.text = self.format(number: String(balance))
                        self.payeeLabel.text = items["payee"] ?? ""
                    }
                }
            }
        }
    }
    
    var idForConfirmation: String?
    
    @IBAction func accept(_ sender: Any) {
        guard let messageURL = activeConversation?.selectedMessage?.url else { return }
        guard let urlComponents = NSURLComponents(url: messageURL, resolvingAgainstBaseURL: false) else { return }
        guard let queryItems = urlComponents.queryItems else { return }
        if queryItems.isEmpty { return }
        guard let user = ZWUser.current else { return }
        var items: [String: String] = [:]
        queryItems.forEach { (item) in
            items[item.name] = item.value ?? ""
        }
        ZWServer.acceptTransfer(id: items[idForConfirmation ?? ""] ?? "", to: user.wallet.accountID)
        self.dismiss()
    }
    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        participants = conversation.remoteParticipantIdentifiers
        // Use this method to configure the extension and restore previously stored state.
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dissmises the extension, changes to a different
        // conversation or quits Messages.
        participants = conversation.remoteParticipantIdentifiers
        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
    }
   
    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.
        participants = conversation.remoteParticipantIdentifiers
//        ZWServer.acceptTransfer(id: String(data.first!), to: String(data.last!))
        // Use this method to trigger UI updates in response to the message.
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
    
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
        // Use this method to prepare for the change in presentation style.
        keypad.isHidden = (presentationStyle == MSMessagesAppPresentationStyle.compact)
    }
    
    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
        // Use this method to finalize any behaviors associated with the change in presentation style.
        checkState()
        keypad.isHidden = (presentationStyle == MSMessagesAppPresentationStyle.compact)
    }
    
    var requestAmount: String = "" { didSet {
        if Int(requestAmount) ?? 0 > 99999 { requestAmount = "100000" }
        displayRequestText()
    } }
    @IBOutlet weak var requestLabel: UILabel!
    @IBOutlet weak var requestMultiplierLabel: UILabel!
    @IBOutlet weak var totalLabel: UILabel!
    
    @IBAction func addDigit(_ sender: Any) {
        if let digit = (sender as? UIButton)?.titleLabel?.text {
            requestAmount += digit
        }
    }
    
    @IBAction func removeDigit(_ sender: Any) {
        if requestAmount.count > 0 { requestAmount.removeLast() }
    }
    
    @IBAction func clearDigits(_ sender: Any) {
        requestAmount = ""
    }
    @IBAction func decrement(_ sender: Any) {
        if let value = Int(requestAmount) {
            if value > 100 {
                requestAmount = String(value - 100)
            } else {
                requestAmount = ""
            }
        }
    }
    
    @IBAction func increment(_ sender: Any) {
        if let value = Int(requestAmount) {
            requestAmount = String(value + 100)
        }
        
        if requestAmount == "" {
            requestAmount = "100"
        }
    }
    
    func displayRequestText() {
        requestLabel.text = format(number: requestAmount)
        requestMultiplierLabel.text = "$" + format(number: String((Int(requestAmount) ?? 0) / multiplier))
        totalLabel.text = "$" + format(number: String((Int(requestAmount) ?? 0) / multiplier * multiplier))
    }
    
    func format(number: String) -> String {
        var displayText = number
        while displayText.count < 3 { displayText = "0" + displayText }
        displayText.insert(".", at: displayText.index(displayText.endIndex, offsetBy: -2))
        return displayText
    }
    
    @IBAction func request(_ sender: Any) {
//        DispatchQueue.main.async {
            let amount = (Int(self.requestAmount) ?? 0) / multiplier
            guard let user = ZWUser.current else { return }
            
            var ids: [String] = []
            for _ in 0..<self.multiplier {
                ZWServer.requestTransfer(balance: amount) { (tid) in
                    ids.append(tid)
                }
            }
            
            while ids.count < self.multiplier {
                _ = 0
            }
            
            let layout = MSMessageTemplateLayout()
        
            layout.caption = "Pay \(requestMultiplierLabel.text!) to \(user.firstName)."
            let message = MSMessage()
            message.layout = layout
            
            var items = [URLQueryItem]()
            items.append(URLQueryItem(name: "payee", value: user.firstName))
            items.append(URLQueryItem(name: "payee_id", value: user.wallet.accountID))
            items.append(URLQueryItem(name: "count", value: "\(multiplier)"))
            for i in 0..<ids.count {
                items.append(URLQueryItem(name: "transfer_id\(i)", value: ids[i]))
            }
            var components = URLComponents()
            components.queryItems = items
            message.url = components.url
            
            self.activeConversation?.insert(message, completionHandler: { (error) in
                print(error ?? "")
            })
            
            self.dismiss()
//        }
    }
}
